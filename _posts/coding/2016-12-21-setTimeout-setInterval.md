---
layout: post
title:  setTimeout和setInterval
date:   2016-12-21
categories: coding
tags: [Javascript]
description: ''
---

__JS是单线程，所以许多的“异步调用”（包括ajax）事实上都只是“伪异步”而已。__ 所以其实 setTimeout 和 setInterval 所谓的“异步调用”事实上是通过将代码段插入到代码的执行队列中实现的。当执行 setTimeout 和 setInterval 的时候，定时器timer会根据你设定的时间“准确”地找到代码的插入点，当队列“正常”地执行到插入点时，就触发timer callback回调函数：  

``` javascript
console.log(1);
setTimeout(function(){
    console.log(3);
}, 0);
console.log(2);  // 依次输出：1 2 3

function fn(){
    setTimeout(function(){
        alert('OK?');
    }, 1000);
    while(true) {}
}
fn();   // 由于while这段代码没有执行完，所以setTimeout里面的代码永远不会执行。
```

---

### 一、线程

#### 1. 浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器通常由以下常驻线程组成：GUI 渲染线程，javascript 引擎线程，浏览器事件触发线程，定时触发器线程，异步 http 请求线程。

+ __GUI 渲染线程__：负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间, GUI 渲染线程都是处于挂起状态的,也就是说被”冻结”。即 GUI 渲染线程与 JS 引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。

+ __javascript 引擎线程__：也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。

+ __浏览器事件触发线程__：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于JS的单线程关系所有这些事件都得排队等待 JS 引擎处理。

+ __定时触发器线程__：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 javaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

+ __异步 http 请求线程__：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。


例子1:异步请求是由线程 JavaScript 执行线程、HTTP 请求线程 和 事件触发线程 共同完成的。JavaScript 执行线程 执行异步请求代码，这时浏览器会开一条新的 HTTP 请求线程 来执行请求，JavaScript 执行线程则继续执行 执行队列 中剩下的其他任务。然后在未来的某一时刻 事件触发线程 监视到之前的发起的 HTTP 请求已完成，它就会把完成事件的回调代码插入到 JavaScript 执行队列尾部 等待 JavaScript 执行线程空闲时来处理。

例子2:定时触发（setTimeout 和 setInterval）是由浏览器的 定时器线程 执行的定时计数，然后在定时时间结束时把定时处理函数的执行代码插入到 JavaScript 执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。

---

#### 2. JavaScript 是单线程的

__js调用栈（call stack）__: 函数被调用时，就会被加入到调用栈顶部，执行结束之后，就会从调用栈顶部移除该函数，这种数据结构的关键在于后进先出，即 LIFO（last-in，first-out）。

> 神器网站：[http://latentflip.com/loupe/](http://latentflip.com/loupe/) 可以用来图形化调用栈的过程

#### 3. 任务队列（消息队列）

+ __同步函数__：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。
+ __异步函数__：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。
+ __同步任务__：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。 
+ __异步任务__：主线程发起一个异步请求（即执行异步函数），相应的工作线程（浏览器事件触发线程、异步http请求线程等）接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，将完成消息放到任务（消息）队列，主线程通过事件循环过程去取任务（消息），然后执行一定的动作(调用回调函数)。
    - __任务队列__：任务（消息）队列是一个先进先出的队列，它里面存放着各种任务（消息）。
    - __事件循环（event loop）__：事件循环是指主线程重复从任务（消息）队列中取任务（消息）、执行的过程。取一个任务（消息）并执行的过程叫做一次循环。

### 二、setTimeout(fn, 0) 的作用

零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。也就是说，setTimeout只是将事件插入了任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在setTimeout指定的时间执行。

总结：setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到主线程把同步任务和"任务队列"现有的事件都处理完，才会得到执行。在某种程度上，我们可以利用setTimeout(fn,0)的特性，修正浏览器的任务顺序。

---
---

> [setTimeout(fn, 0) 的作用](http://www.toutiao.com/a6420759034094387457/)